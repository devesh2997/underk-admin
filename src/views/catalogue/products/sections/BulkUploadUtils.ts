//This function checks for valid product fields which are provided during creation of a new product..

import { ProductCreateInfo, BulkUploadProductCreateInfo } from "data/catalogue/ProductsRepository"
import Type from "models/catalogue/Type"
import { Category } from "models/catalogue/Category"
import { isEmpty } from "lodash"
import { Warehouse } from "models/inventory/Warehouse"
import { AttributeValue } from "models/catalogue/AttributeValue"
import { OptionAttributeValue } from "models/catalogue/OptionAttributeValue"
import { SKUAttributeValue } from "models/catalogue/SKUAttributeValue"
import { Collection } from "models/catalogue/Collection";
import { Price } from "models/catalogue/Price"
import { Dimensions } from "models/catalogue/Dimensions"
import { Subtype } from "models/catalogue/Subtype"


type ProductCreateInfoValidationResult = {
    isValid: boolean
    error?: string
    // product?: Product
}

const createValidationErrorObject = (error: string) => {
    return { isValid: false, error: error }
}

//function to parse the Map generated by convertCSVDataArrayToProductNumberBasedMap function and return an array of proper product create info objects
//This throws an error if duplicate warehouse code exists for the same option name.
export const parseProductNumberBasedMap = (csvDataMap: Map<any, any>, selectedType: Type, selectedSubtype: Subtype): BulkUploadProductCreateInfo[] => {
    const productsCreateInfo: BulkUploadProductCreateInfo[] = [];
    csvDataMap.forEach((productsData: any[], productNumber) => {
        //empty rows in the csv will generate and empty product number which we will have to skip
        if (productNumber !== "") {
            //just a precaution for edge cases
            if (productsData.length !== 0) {
                //get the values for the first productData, this will contain all the common product related values/info
                const productData = productsData[0];
                const title = productData[1];
                const slug = productData[2];
                const categorySlug = productData[3];
                const collectionsSlugsString = productData[4];
                const collectionsSlugs = collectionsSlugsString
                    .split(",")
                    .map((coll: string) => coll.trim());
                //currenCol will define the next column that is to be read and parsed
                let currentCol = 5;
                const productCreateInfo: ProductCreateInfo = {
                    title,
                    slug,
                    categorySlug,
                    collectionsSlugs,
                    typeName: selectedType?.name!,
                    subtypeName: selectedSubtype?.name!,
                    productSKUAttributeValues: [],
                };
                selectedSubtype?.skuAttributes.forEach((skuAttr) => {
                    productCreateInfo.productSKUAttributeValues.push({
                        skuAttributeName: skuAttr.name,
                        skuAttributeValueName: productData[currentCol],
                    });
                    currentCol++;
                });
                if (typeof selectedSubtype?.attributes !== "undefined") {
                    productCreateInfo.productAttributeValues = [];
                    selectedSubtype.attributes.forEach((attr) => {
                        const attributeValue: {
                            attributeName: string;
                            attributeValueName?: string;
                            attributeValueNames?: string[];
                        } = { attributeName: attr.name };
                        if (attr.isMultiValued) {
                            const attributeValueNamesString = productData[currentCol];
                            const attributeValueNames = attributeValueNamesString
                                .split(",")
                                .map((name: string) => name.trim());
                            attributeValue["attributeValueNames"] = attributeValueNames;
                        } else {
                            attributeValue.attributeValueName = productData[currentCol];
                        }
                        currentCol++;
                        productCreateInfo?.productAttributeValues?.push(
                            attributeValue
                        );
                    });
                }
                if (typeof selectedSubtype?.optionAttribute !== "undefined") {
                    productCreateInfo.productOptionAttributeValues = [];

                    //check if muliple rows of the same product have the same option name and warehouse code
                    for (let i = 0; i < productsData.length - 1; i++) {
                        const pData = productsData[i];
                        for (let j = i + 1; j < productsData.length; j++) {
                            const pDataOther = productsData[j];
                            if (
                                pData[currentCol] === pDataOther[currentCol] &&
                                pData[currentCol + 9] === pDataOther[currentCol + 9]
                            ) {
                                throw `Product ${productNumber} has muliple rows with the same option and warehouse code`;
                            }
                        }
                    }
                    productsData.forEach((pData) => {
                        const optionName = pData[currentCol];
                        if (
                            !productCreateInfo.productOptionAttributeValues?.find(
                                (poav) => poav.optionAttributeValueName === optionName
                            )
                        ) {
                            productCreateInfo.productOptionAttributeValues?.push({
                                optionAttributeValueName: optionName,
                                optionAttributeValuePrice: {
                                    currency: "INR",
                                    listPrice: pData[currentCol + 1],
                                    salePrice: pData[currentCol + 2],
                                    taxPercent: pData[currentCol + 3],
                                    isInclusiveTax: pData[currentCol + 4],
                                },
                                optionAttributeValueDimensions: {
                                    length: pData[currentCol + 5],
                                    breadth: pData[currentCol + 6],
                                    height: pData[currentCol + 7],
                                    weight: pData[currentCol + 8],
                                },
                                optionAttributeValueInventory: [
                                    {
                                        warehouseCode: pData[currentCol + 9],
                                        stock: pData[currentCol + 10],
                                    },
                                ],
                            });
                        } else {
                            productCreateInfo.productOptionAttributeValues
                                ?.find(
                                    (poav) => poav.optionAttributeValueName === optionName
                                )
                                ?.optionAttributeValueInventory?.push({
                                    warehouseCode: pData[currentCol + 9],
                                    stock: pData[currentCol + 10],
                                });
                        }
                    });
                } else {
                    productCreateInfo.price = {
                        currency: "INR",
                        listPrice: productData[currentCol],
                        salePrice: productData[currentCol + 1],
                        taxPercent: productData[currentCol + 2],
                        isInclusiveTax: productData[currentCol + 3],
                    };
                    productCreateInfo.productDimensions = {
                        length: productData[currentCol + 4],
                        breadth: productData[currentCol + 5],
                        height: productData[currentCol + 6],
                        weight: productData[currentCol + 7],
                    };
                    //check if muliple rows of the same product have the same warehouse code
                    for (let i = 0; i < productsData.length - 1; i++) {
                        const pData = productsData[i];
                        for (let j = i + 1; j < productData.length; j++) {
                            const pDataOther = productData[j];
                            if (pData[currentCol + 4] === pDataOther[currentCol + 4]) {
                                throw `Product ${productNumber} has muliple rows with the same warehouse code`;
                            }
                        }
                    }
                    productCreateInfo.productInventory = [];
                    productsData.forEach((pData) => {
                        productCreateInfo.productInventory?.push({
                            warehouseCode: pData[currentCol + 8],
                            stock: pData[currentCol + 9],
                        });
                    });
                }
                productsCreateInfo.push({ productInfo: productCreateInfo, productNumber: productNumber });
            }
        }
    });
    return productsCreateInfo;
}

//converts csvRows array to map in which product numbers are keys and the rows of that product number are values (as array)

export const convertCSVDataArrayToProductNumberBasedMap = (csvData: any[]) => {
    const csvDataMapByProductNumber = new Map();

    //check for duplicate slugs
    for (let i = 0; i < csvData.length - 1; i++) {
        const row = csvData[i];
        for (let j = i + 1; j < csvData.length; j++) {
            const otherRow = csvData[j]
            if (row[2] === otherRow[2]) {
                throw `Duplicate slugs found at row ${i + 1} and ${j + 1}`
            }
        }
    }

    for (let i = 1; i < csvData.length; i++) {
        const row = csvData[i];
        //trim all the column values of row
        for (let j = 0; j < row.length; j++) {
            row[j] = row[j].trim();
        }
        const productNumber = row[0];
        if (typeof csvDataMapByProductNumber.get(productNumber) === "undefined") {
            csvDataMapByProductNumber.set(productNumber, []);
        }
        // console.log(csvDataMapByProductNumber.get(productNumber))
        const currentProducts = csvDataMapByProductNumber.get(productNumber);
        currentProducts.push(row);
        csvDataMapByProductNumber.set(productNumber, currentProducts);
    }
    return csvDataMapByProductNumber;
}

//this function validates the price field
export const validatePriceInfo = (price: Price): ProductCreateInfoValidationResult => {
    if (isEmpty(price.currency)) {
        return createValidationErrorObject("Currency not provided")
    }
    if (isEmpty(price.listPrice) || isNaN(Number(price.listPrice))) {
        return createValidationErrorObject("Invalid list price provided")
    }
    if (isEmpty(price.salePrice) || isNaN(Number(price.salePrice))) {
        return createValidationErrorObject("Invalid sale price provided")
    }
    if (isEmpty(price.taxPercent) || isNaN(Number(price.taxPercent))) {
        return createValidationErrorObject("Invalid tax percent provided")
    }
    if (isEmpty(price.isInclusiveTax)) {
        return createValidationErrorObject("Please provide if the price is inclusive tax or not.")
    }

    return { isValid: true }
}

//this function validates the dimension info
const validateDimensionsInfo = (dimensions: Dimensions): ProductCreateInfoValidationResult => {
    if (isEmpty(dimensions)) {
        return createValidationErrorObject('Dimension must be provided')
    }
    if (!isEmpty(dimensions.length)) {
        if (isNaN(Number(dimensions.length))) {
            return createValidationErrorObject("Invalid length dimension provided")
        }
    }
    if (!isEmpty(dimensions.breadth)) {
        if (isNaN(Number(dimensions.length))) {
            return createValidationErrorObject("Invalid length dimension provided")
        }
    }
    if (!isEmpty(dimensions.height)) {
        if (isNaN(Number(dimensions.length))) {
            return createValidationErrorObject("Invalid length dimension provided")
        }
    }
    if (isEmpty(dimensions.weight)) {
        return createValidationErrorObject("Product weight(in gm) should be compulsorily provided.")
    } else {
        if (isNaN(dimensions.weight)) {
            return createValidationErrorObject("Invalid product weight is given.")
        }
    }

    return { isValid: true }
}
