//This function checks for valid product fields which are provided during creation of a new product..

import { ProductCreateInfo, BulkUploadProductCreateInfo } from "data/catalogue/ProductsRepository"
import Type from "models/catalogue/Type"
import { Category } from "models/catalogue/Category"
import { isEmpty } from "lodash"
import { Warehouse } from "models/inventory/Warehouse"
import { AttributeValue } from "models/catalogue/AttributeValue"
import { OptionAttributeValue } from "models/catalogue/OptionAttributeValue"
import { SKUAttributeValue } from "models/catalogue/SKUAttributeValue"
import { Collection } from "models/catalogue/Collection";
import { isNotEmpty } from "utils"
import { Price } from "models/catalogue/Price"
import { Dimensions } from "models/catalogue/Dimensions"
import { Subtype } from "models/catalogue/Subtype"


type ProductCreateInfoValidationResult = {
    isValid: boolean
    error?: string
    // product?: Product
}

const createValidationErrorObject = (error: string) => {
    return { isValid: false, error: error }
}

//function to parse the Map generated by convertCSVDataArrayToProductNumberBasedMap function and return an array of proper product create info objects
//This throws an error if duplicate warehouse code exists for the same option name.
export const parseProductNumberBasedMap = (csvDataMap: Map<any, any>, selectedType: Type, selectedSubtype: Subtype): BulkUploadProductCreateInfo[] => {
    const productsCreateInfo: BulkUploadProductCreateInfo[] = [];
    csvDataMap.forEach((productsData: any[], productNumber) => {
        //empty rows in the csv will generate and empty product number which we will have to skip
        if (productNumber !== "") {
            //just a precaution for edge cases
            if (productsData.length !== 0) {
                //get the values for the first productData, this will contain all the common product related values/info
                const productData = productsData[0];
                const title = productData[1];
                const slug = productData[2];
                const categorySlug = productData[3];
                const collectionsSlugsString = productData[4];
                const collectionsSlugs = collectionsSlugsString
                    .split(",")
                    .map((coll: string) => coll.trim());
                //currenCol will define the next column that is to be read and parsed
                let currentCol = 5;
                const productCreateInfo: ProductCreateInfo = {
                    title,
                    slug,
                    categorySlug,
                    collectionsSlugs,
                    typeName: selectedType?.name!,
                    subtypeName: selectedSubtype?.name!,
                    productSKUAttributeValues: [],
                };
                selectedSubtype?.skuAttributes.forEach((skuAttr) => {
                    productCreateInfo.productSKUAttributeValues.push({
                        skuAttributeName: skuAttr.name,
                        skuAttributeValueName: productData[currentCol],
                    });
                    currentCol++;
                });
                if (typeof selectedSubtype?.attributes !== "undefined") {
                    productCreateInfo.productAttributeValues = [];
                    selectedSubtype.attributes.forEach((attr) => {
                        const attributeValue: {
                            attributeName: string;
                            attributeValueName?: string;
                            attributeValueNames?: string[];
                        } = { attributeName: attr.name };
                        if (attr.isMultiValued) {
                            const attributeValueNamesString = productData[currentCol];
                            const attributeValueNames = attributeValueNamesString
                                .split(",")
                                .map((name: string) => name.trim());
                            attributeValue["attributeValueNames"] = attributeValueNames;
                        } else {
                            attributeValue.attributeValueName = productData[currentCol];
                        }
                        currentCol++;
                        productCreateInfo?.productAttributeValues?.push(
                            attributeValue
                        );
                    });
                }
                if (typeof selectedSubtype?.optionAttribute !== "undefined") {
                    productCreateInfo.productOptionAttributeValues = [];

                    //check if muliple rows of the same product have the same option name and warehouse code
                    for (let i = 0; i < productsData.length - 1; i++) {
                        const pData = productsData[i];
                        for (let j = i + 1; j < productsData.length; j++) {
                            const pDataOther = productsData[j];
                            if (
                                pData[currentCol] === pDataOther[currentCol] &&
                                pData[currentCol + 9] === pDataOther[currentCol + 9]
                            ) {
                                throw `Product ${productNumber} has muliple rows with the same option and warehouse code`;
                            }
                        }
                    }
                    productsData.forEach((pData) => {
                        const optionName = pData[currentCol];
                        if (
                            !productCreateInfo.productOptionAttributeValues?.find(
                                (poav) => poav.optionAttributeValueName === optionName
                            )
                        ) {
                            productCreateInfo.productOptionAttributeValues?.push({
                                optionAttributeValueName: optionName,
                                optionAttributeValuePrice: {
                                    currency: "INR",
                                    listPrice: pData[currentCol + 1],
                                    salePrice: pData[currentCol + 2],
                                    taxPercent: pData[currentCol + 3],
                                    isInclusiveTax: pData[currentCol + 4],
                                },
                                optionAttributeValueDimensions: {
                                    length: pData[currentCol + 5],
                                    breadth: pData[currentCol + 6],
                                    height: pData[currentCol + 7],
                                    weight: pData[currentCol + 8],
                                },
                                optionAttributeValueInventory: [
                                    {
                                        warehouseCode: pData[currentCol + 9],
                                        stock: pData[currentCol + 10],
                                    },
                                ],
                            });
                        } else {
                            productCreateInfo.productOptionAttributeValues
                                ?.find(
                                    (poav) => poav.optionAttributeValueName === optionName
                                )
                                ?.optionAttributeValueInventory?.push({
                                    warehouseCode: pData[currentCol + 9],
                                    stock: pData[currentCol + 10],
                                });
                        }
                    });
                } else {
                    productCreateInfo.price = {
                        currency: "INR",
                        listPrice: productData[currentCol],
                        salePrice: productData[currentCol + 1],
                        taxPercent: productData[currentCol + 2],
                        isInclusiveTax: productData[currentCol + 3],
                    };
                    productCreateInfo.productDimensions = {
                        length: productData[currentCol + 4],
                        breadth: productData[currentCol + 5],
                        height: productData[currentCol + 6],
                        weight: productData[currentCol + 7],
                    };
                    //check if muliple rows of the same product have the same warehouse code
                    for (let i = 0; i < productsData.length - 1; i++) {
                        const pData = productsData[i];
                        for (let j = i + 1; j < productData.length; j++) {
                            const pDataOther = productData[j];
                            if (pData[currentCol + 4] === pDataOther[currentCol + 4]) {
                                throw `Product ${productNumber} has muliple rows with the same warehouse code`;
                            }
                        }
                    }
                    productCreateInfo.productInventory = [];
                    productsData.forEach((pData) => {
                        productCreateInfo.productInventory?.push({
                            warehouseCode: pData[currentCol + 8],
                            stock: pData[currentCol + 9],
                        });
                    });
                }
                productsCreateInfo.push({ productInfo: productCreateInfo, productNumber: productNumber });
            }
        }
    });
    return productsCreateInfo;
}

//converts csvRows array to map in which product numbers are keys and the rows of that product number are values (as array)

export const convertCSVDataArrayToProductNumberBasedMap = (csvData: any[]) => {
    const csvDataMapByProductNumber = new Map();

    //check for duplicate slugs
    for (let i = 0; i < csvData.length - 1; i++) {
        const row = csvData[i];
        for (let j = i + 1; j < csvData.length; j++) {
            const otherRow = csvData[j]
            if (row[2] === otherRow[2]) {
                throw `Duplicate slugs found at row ${i + 1} and ${j + 1}`
            }
        }
    }

    for (let i = 1; i < csvData.length; i++) {
        const row = csvData[i];
        //trim all the column values of row
        for (let j = 0; j < row.length; j++) {
            row[j] = row[j].trim();
        }
        const productNumber = row[0];
        if (typeof csvDataMapByProductNumber.get(productNumber) === "undefined") {
            csvDataMapByProductNumber.set(productNumber, []);
        }
        // console.log(csvDataMapByProductNumber.get(productNumber))
        const currentProducts = csvDataMapByProductNumber.get(productNumber);
        currentProducts.push(row);
        csvDataMapByProductNumber.set(productNumber, currentProducts);
    }
    return csvDataMapByProductNumber;
}

//this function validates the price field
export const validatePriceInfo = (price: Price): ProductCreateInfoValidationResult => {
    if (isEmpty(price.currency)) {
        return createValidationErrorObject("Currency not provided")
    }
    if (isEmpty(price.listPrice) || isNaN(Number(price.listPrice))) {
        return createValidationErrorObject("Invalid list price provided")
    }
    if (isEmpty(price.salePrice) || isNaN(Number(price.salePrice))) {
        return createValidationErrorObject("Invalid sale price provided")
    }
    if (isEmpty(price.taxPercent) || isNaN(Number(price.taxPercent))) {
        return createValidationErrorObject("Invalid tax percent provided")
    }
    if (isEmpty(price.isInclusiveTax)) {
        return createValidationErrorObject("Please provide if the price is inclusive tax or not.")
    }

    return { isValid: true }
}

//this function validates the dimension info
const validateDimensionsInfo = (dimensions: Dimensions): ProductCreateInfoValidationResult => {
    if (isEmpty(dimensions)) {
        return createValidationErrorObject('Dimension must be provided')
    }
    if (!isEmpty(dimensions.length)) {
        if (isNaN(Number(dimensions.length))) {
            return createValidationErrorObject("Invalid length dimension provided")
        }
    }
    if (!isEmpty(dimensions.breadth)) {
        if (isNaN(Number(dimensions.length))) {
            return createValidationErrorObject("Invalid length dimension provided")
        }
    }
    if (!isEmpty(dimensions.height)) {
        if (isNaN(Number(dimensions.length))) {
            return createValidationErrorObject("Invalid length dimension provided")
        }
    }
    if (isEmpty(dimensions.weight)) {
        return createValidationErrorObject("Product weight(in gm) should be compulsorily provided.")
    } else {
        if (isNaN(dimensions.weight)) {
            return createValidationErrorObject("Invalid product weight is given.")
        }
    }

    return { isValid: true }
}

//This does not check for uniqueness of product slug..
export const validateProductCreateInfo = (productInfo: ProductCreateInfo, types: Type[], categories: Category[], collections: Collection[], warehouses: Warehouse[]): ProductCreateInfoValidationResult => {
    if (isEmpty(productInfo.slug)) {
        return createValidationErrorObject("Product slug not provided")
    }
    if (isEmpty(productInfo.title)) {
        return createValidationErrorObject("Product title not provided")
    }
    if (isEmpty(productInfo.typeName)) {
        return createValidationErrorObject("Type Name not provided")

    }
    if (isEmpty(productInfo.subtypeName)) {
        return createValidationErrorObject("Type Name not provided")
    }
    if (isEmpty(productInfo.categorySlug)) {
        return createValidationErrorObject("Category Slug not provided")
    }

    const type = types.find(type => type.name === productInfo.typeName)
    if (typeof type === 'undefined') {
        return createValidationErrorObject("Type with given name not found.");
    }

    const subtypes = type.subtypes
    if (typeof subtypes === 'undefined') {
        return createValidationErrorObject(`Type ${type.name} does not have any subtypes.`)
    }
    const subtype = subtypes.find(subtype => subtype.name === productInfo.subtypeName)
    if (typeof subtype === 'undefined') {
        return createValidationErrorObject("Subtype with given name not found.");
    }

    const productCategory = categories.find(category => category.slug === productInfo.categorySlug)
    if (typeof productCategory === 'undefined') {
        return createValidationErrorObject("Category with given slug not found.")
    }

    const productInfoCollections = productInfo.collectionsSlugs.map(collectionSlug => collections.find(collection => collection.slug === collectionSlug))
    for (let i = 0; i < productInfoCollections.length; i++) {
        if (typeof productInfoCollections[i] === 'undefined') {
            return createValidationErrorObject(`collection with slug ${productInfo.collectionsSlugs[i]} not found`)
        }
    }

    let attributeValues: AttributeValue[] = []
    let optionAttributeValues: OptionAttributeValue[] = []
    let skuAttributeValues: SKUAttributeValue[] = []
    const { productAttributeValues, productSKUAttributeValues, productOptionAttributeValues } = productInfo
    if (isEmpty(productSKUAttributeValues)) {
        return createValidationErrorObject("SKU attribute values cannot be empty")
    }

    for (let i = 0; i < subtype.skuAttributes.length; i++) {
        const sa = subtype.skuAttributes[i]
        const productSKUAttribute = productSKUAttributeValues.find((psav) => psav.skuAttributeName === sa.name)
        if (typeof productSKUAttribute === 'undefined') {
            return createValidationErrorObject(`Value of sku attribute ${sa.name} not provided`)
        } else {
            const productSKUAttributeValue = sa.values.find((sav) => sav.name === productSKUAttribute.skuAttributeValueName)
            if (typeof productSKUAttributeValue === 'undefined') {
                return createValidationErrorObject(`Value for sku attribute ${sa.name} : ${productSKUAttribute.skuAttributeValueName} does not exist`)
            }
            skuAttributeValues.push(productSKUAttributeValue)
        }
    }

    if (isNotEmpty(subtype.optionAttribute)) {
        if (typeof productOptionAttributeValues !== 'undefined') {
            if (productOptionAttributeValues.length === 0) {
                return createValidationErrorObject("Atleast one option must be provided")
            }

            for (let i = 0; i < productOptionAttributeValues.length; i++) {
                const poav = productOptionAttributeValues[i]
                const subtypeOptionAttributeValue = subtype.optionAttribute?.values.find((v) => v.name === poav.optionAttributeValueName)
                if (typeof subtypeOptionAttributeValue === 'undefined') {
                    return createValidationErrorObject(`No subtype option attribute for ${subtype.optionAttribute?.name} exists named ${poav.optionAttributeValueName}`)
                }
                if (typeof poav.optionAttributeValuePrice === 'undefined') {
                    return createValidationErrorObject("Price not provided")
                } else {
                    const priceValidation = validatePriceInfo(poav.optionAttributeValuePrice)
                    if (!priceValidation.isValid) {
                        return priceValidation
                    }
                }

                const dimensionsValidation = validateDimensionsInfo(poav.optionAttributeValueDimensions)
                if (!dimensionsValidation.isValid) {
                    return dimensionsValidation
                }

                if (typeof poav.optionAttributeValueInventory !== 'undefined') {
                    for (let j = 0; j < poav.optionAttributeValueInventory.length; j++) {
                        const productWarehouseInventory = poav.optionAttributeValueInventory[j]
                        const warehouse = warehouses.find(w => w.code === productWarehouseInventory.warehouseCode)
                        if (typeof warehouse === 'undefined') {
                            return createValidationErrorObject(`warehouse with code ${productWarehouseInventory.warehouseCode} does not exist`)
                        }
                        productWarehouseInventory.stock = Number(productWarehouseInventory.stock)
                        if (isNaN(productWarehouseInventory.stock)) {
                            return createValidationErrorObject(`Invalid stock given for warehouse ${productWarehouseInventory.warehouseCode}`)
                        }
                    }
                }
                optionAttributeValues.push(subtypeOptionAttributeValue)
            }
        } else {
            return createValidationErrorObject("Atleast one option must be provided")
        }

    } else {
        if (typeof productInfo.price === 'undefined') {
            return createValidationErrorObject('Price details are not provided')
        } else {
            const priceValidation = validatePriceInfo(productInfo.price)
            if (!priceValidation.isValid) {
                return priceValidation
            }

        }
        if (typeof productInfo.productDimensions === 'undefined') {
            return createValidationErrorObject('Product Dimesions must be given')
        } else {
            const dimensionsValidation = validateDimensionsInfo(productInfo.productDimensions)
            if (!dimensionsValidation.isValid) {
                return dimensionsValidation
            }
        }
        if (typeof productInfo.productInventory !== 'undefined') {
            for (let j = 0; j < productInfo.productInventory.length; j++) {
                const productWarehouseInventory = productInfo.productInventory[j]
                const warehouse = warehouses.find(w => w.code === productWarehouseInventory.warehouseCode)
                if (typeof warehouse === 'undefined') {
                    return createValidationErrorObject(`warehouse with code ${productWarehouseInventory.warehouseCode} does not exist`)
                }
                productWarehouseInventory.stock = Number(productWarehouseInventory.stock)
                if (isNaN(productWarehouseInventory.stock)) {
                    return createValidationErrorObject(`Invalid stock given for warehouse ${productWarehouseInventory.warehouseCode}`)
                }
            }
        }

    }

    if (typeof subtype.attributes !== 'undefined') {
        for (let i = 0; i < subtype.attributes.length; i++) {
            const subtypeAttribute = subtype.attributes[i]
            const a = productAttributeValues?.find(pattr => pattr.attributeName === subtypeAttribute.name)
            if (subtypeAttribute.isCompulsory) {
                if (subtypeAttribute.isMultiValued) {
                    if (typeof a === 'undefined' || typeof a.attributeValueNames === 'undefined' || a.attributeValueNames.length === 0) {
                        return createValidationErrorObject(`Atleast one value must be provided for compulsory attribute ${subtypeAttribute.name}`)
                    }
                } else {
                    if (typeof a === 'undefined' || typeof a.attributeValueName === undefined || a.attributeValueName?.length === 0) {
                        return createValidationErrorObject(`Value must be provided for compulsory attribute ${subtypeAttribute.name}`)
                    }
                }
            }
            if (subtypeAttribute.isMultiValued) {
                if (typeof a !== 'undefined' && typeof a.attributeValueNames !== 'undefined') {
                    for (let i = 0; i < a.attributeValueNames.length; i++) {
                        const aValueName = a.attributeValueNames[i]
                        const subtypeAttributeValue = subtypeAttribute.values.find((sav) => sav.name === aValueName)
                        if (typeof subtypeAttributeValue === 'undefined') {
                            return createValidationErrorObject(`Attribute value with name ${aValueName} not found for ${a.attributeName}`)
                        }
                    }
                }
            } else {
                if (typeof a !== 'undefined') {
                    const subtypeAttributeValue = subtypeAttribute.values.find((sav) => sav.name === a.attributeValueName)
                    if (typeof subtypeAttributeValue === 'undefined') {
                        return createValidationErrorObject(`Attribute value with name ${a.attributeValueName} Not found for ${a.attributeName}`)
                    }
                }

            }
        }
    }


    // for (let i = 0; i < productAttributeValues.length; i++) {
    //     const a = productAttributeValues[i]
    //     const subtypeAttribute = subtype.attributes.find((sa) => sa.name === a.attributeName)
    //     if (typeof subtypeAttribute === 'undefined') {
    //         return createValidationErrorObject(`Attribute with name ${a.attributeName} Not found`)
    //     } else {
    //         if (subtypeAttribute.isCompulsory) {
    //             if (subtypeAttribute.isMultiValued) {
    //                 if (typeof a.attributeValueNames === 'undefined' || a.attributeValueNames.length === 0) {
    //                     return createValidationErrorObject(`Atleast one value must be provided for compulsory attribute ${a.attributeName}`)
    //                 }
    //             } else {
    //                 if (typeof a.attributeValueName === undefined || a.attributeValueName?.length === 0) {
    //                     return createValidationErrorObject(`Value must be provided for compulsory attribute ${a.attributeName}`)
    //                 }
    //             }
    //         }
    //         if (subtypeAttribute.isMultiValued) {
    //             if (typeof a.attributeValueNames !== 'undefined') {
    //                 for (let i = 0; i < a.attributeValueNames.length; i++) {
    //                     const aValueName = a.attributeValueNames[i]
    //                     const subtypeAttributeValue = subtypeAttribute.values.find((sav) => sav.name === aValueName)
    //                     if (typeof subtypeAttributeValue === 'undefined') {
    //                         return createValidationErrorObject(`Attribute value with name ${aValueName} not found for ${a.attributeName}`)
    //                     }
    //                 }
    //             }
    //         } else {
    //             const subtypeAttributeValue = subtypeAttribute.values.find((sav) => sav.name === a.attributeValueName)
    //             if (typeof subtypeAttributeValue === 'undefined') {
    //                 return createValidationErrorObject(`Attribute value with name ${a.attributeValueName} Not found for ${a.attributeName}`)
    //             }
    //         }

    //     }
    // }

    return { isValid: true }

}